

<h1 id="sec:introduction">Introduction</h1>
<p>As someone “classically trained” in differential geometry, my recent adventures in homotopy type theory have made me very excited to explore an entirely new angle on a topic I love. It is the case today that modal HoTT allows us to access smoothness and prove theorems about manifolds, Lie groups and more. In order to participate in this new and exciting field, someone like me needs a bridge. More than one, in fact. The current document is intended as one of those bridges. Starting from the classical definition of a smooth manifold and the category containing these objects and the smooth maps between them, we will define several enlargements of the category until we arrive at something where modal HoTT can be interpreted.</p>
<p>To make the most of this process, we will always try to keep track of where smoothness is entering in. It’s not always obvious!</p>
<p><span id="def:smoothmfd" label="def:smoothmfd">[def:smoothmfd]</span> A smooth manifold is a Hausdorff topological space <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> with countable basis, and with a maximal smooth atlas. An atlas is a covering of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> by open sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>i</mi></msub><annotation encoding="application/x-tex">U_i</annotation></semantics></math>, each of which is the image of a homeomorphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>:</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">f_i:\mathbb{R}^n\to M</annotation></semantics></math> (called a <em>chart</em>), such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>f</mi><mi>j</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo>∘</mo><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_j^{-1}\circ f_i</annotation></semantics></math> is smooth wherever it is defined. Two atlases are compatible if their union is again an atlas. The maximal atlas is the union of all compatible atlases.</p>
<p>Note that this definition expresses <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> as a colimit of a diagram of arrows from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n\to M</annotation></semantics></math>, more specifically a pushout. More on this shortly.</p>
<p>A continuous function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">f:M\to N</annotation></semantics></math> between two smooth manifolds is defined to be smooth if the appropriate composition with charts is a smooth function between cartesian spaces.</p>
<p>The category <span class="sans-serif">SmoothMfd</span> has objects the smooth manifolds of any finite dimension, and morphisms the smooth maps.</p>
<p>This category, innocuous though it seems, has some strange properties! There are topological manifolds that are missing from it, and some that are way over-represented! You can’t just take a topological manifold and assume you can give it a unique maximal smooth atlas and stick it into <span class="sans-serif">SmoothMfd</span>.</p>
<p>The table below contains some examples.</p>
<p><span id="table:smoothstructures" label="table:smoothstructures">[table:smoothstructures]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">kind of manifold</th>
<th style="text-align: left;">number of inequivalent smooth atlases</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">dim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\leq 3</annotation></semantics></math></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">dim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\geq 5</annotation></semantics></math></td>
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\geq 0</annotation></semantics></math>, finite</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>,</mo><mi>n</mi><mo>≠</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n, n\neq 4</annotation></semantics></math></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>4</mn></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^4</annotation></semantics></math></td>
<td style="text-align: left;">uncountably many</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>S</mi><mn>4</mn></msup><annotation encoding="application/x-tex">S^4</annotation></semantics></math></td>
<td style="text-align: left;">unknown, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\geq 1</annotation></semantics></math></td>
</tr>
<tr class="even">
<td style="text-align: left;">dim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">= 4</annotation></semantics></math>, compact without boundary</td>
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\geq 0</annotation></semantics></math>, at most countably many</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">= 4</annotation></semantics></math>, otherwise</td>
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\geq 1</annotation></semantics></math>, at most uncountably many</td>
</tr>
</tbody>
</table>
<p>The claim that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>S</mi><mn>4</mn></msup><annotation encoding="application/x-tex">S^4</annotation></semantics></math> has exactly one smooth structure is known as the four-dimensional smooth Poincaré conjecture. Its status is “extremely unknown”. For more of the beautiful story around four-dimensional topology and smooth structures see the accessible and detailed book by Scorpan <span class="citation" data-cites="scorpan_wild_2005"></span>.</p>
<p>The spheres behave surprisingly as well.</p>
<p><span id="table:smoothspheres" label="table:smoothspheres">[table:smoothspheres]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math></th>
<th style="text-align: left;">number of inequivalent smooth atlases on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>S</mi><mi>n</mi></msup><annotation encoding="application/x-tex">S^n</annotation></semantics></math></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\geq 1</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">7</td>
<td style="text-align: left;">28</td>
</tr>
<tr class="even">
<td style="text-align: left;">8</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">9</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td style="text-align: left;">6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: left;">992</td>
</tr>
<tr class="even">
<td style="text-align: left;">12</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">13</td>
<td style="text-align: left;">3</td>
</tr>
<tr class="even">
<td style="text-align: left;">14</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">15</td>
<td style="text-align: left;">16256</td>
</tr>
<tr class="even">
<td style="text-align: left;">16</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">17</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">18</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">19</td>
<td style="text-align: left;">523264</td>
</tr>
<tr class="even">
<td style="text-align: left;">20</td>
<td style="text-align: left;">24</td>
</tr>
</tbody>
</table>
<p>(from https://en.wikipedia.org/wiki/Differential_structure)</p>
<p>Is <span class="sans-serif">SmoothMfd</span> a nice category? It does have finite products (cartesian product) and coproducts (disjoint unions). Manifolds are themselves certain colimits. However in this category does not have all limits or colimits, nor is it cartesian closed.</p>
<p>For example, consider the equalizer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mi>y</mi><mo>=</mo><mn>0</mn><mo stretchy="true" form="postfix">}</mo></mrow><mo>⊂</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\left\{(x, y) | xy = 0\right\}\subset \ensuremath{\mathbb{R}}^2</annotation></semantics></math>. As a set this must be equal to the union of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>-axis and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-axis. But this cannot be given the structure of a topological manifold nor a smooth one, due to the failure to be homeomorphic to any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math> at the origin. Full argument: the forgetful functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mtext mathvariant="sans-serif">𝖲𝗆𝗈𝗈𝗍𝗁𝖬𝖿𝖽</mtext><mo>→</mo><mtext mathvariant="sans-serif">𝖲𝖾𝗍</mtext></mrow><annotation encoding="application/x-tex">U:\textsf{SmoothMfd}\to\textsf{Set}</annotation></semantics></math> preserves limits and colimits as it has both left and right adjoints. The equalizer as a set is this union of axes, and so the manifold must have that underlying set. But this set cannot be promoted to a smooth manifold.</p>
<p>Consider the coequalizer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><mo>∐</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>∼</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\left(\mathbb{R}^2 \coprod \mathbb{R}\right)/(0,0)\sim 0</annotation></semantics></math>. Similarly this cannot be given the structure of a topological manifold nor a smooth one, also at the origin.</p>
<p>Is <span class="sans-serif">SmoothMfd</span> cartesian closed, i.e. does it contain function spaces of smooth maps? This has been attempted with some success, but we’ll skip over that story because we’re going to do it with sheaves later. In fact right now.</p>
<h1 id="sec:sheaves">Sheaves on <span class="sans-serif">CartSp</span></h1>
<p>My take on presheaves and sheaves is inspired by Daniel Dugger’s informal notes <em>Sheaves and Homotopy Theory</em><span class="citation" data-cites="dugger_sheaves_1999"></span>. His analogy to generators and relations is the one that clicked for me in this context.</p>
<p>Define <span class="sans-serif">CartSp</span> to be the full subcategory of <span class="sans-serif">SmoothMfd</span> containing just the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math> for finite <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> (recall that “full” means include every morphism). In the case of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>4</mn></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^4</annotation></semantics></math> let’s just bring the standard smooth structure. We can try to build the fake <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>4</mn></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^4</annotation></semantics></math>s later on with surgery and such.</p>
<p>Due to the existence of real-valued functions such as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac><annotation encoding="application/x-tex">\frac{1}{1+e^{-x}}</annotation></semantics></math> we can map all of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math> to the open interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math>. So note that this category is not as pitifully empty as I, at least, thought at first. You can cover <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math> with balls each of which is a diffeomorphic image of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math>. We’ll be doing just that.</p>
<p>To generalize <span class="sans-serif">SmoothMfd</span> we’ll use <span class="sans-serif">CartSp</span> in a new way. In the original atlas-based definition of a smooth manifold we were characterizing manifolds by the slogan “locally isomorphic to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math>.” This is a way to cash out the more general concept “modeled on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math>.” But we will now shift to the paradigm “can be probed by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math>” or equivalently “has specified maps from the test spaces <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math>.” In this framework we will specify probes from all dimensions of cartesian spaces, not just the one that has the same dimension as the manifold (if any such concept as dimension survives our shenanigans).</p>
<p>A <em>presheaf</em> on <span class="sans-serif">CartSp</span> is a functor <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext><mstyle mathvariant="normal"><mi>o</mi><mi>p</mi></mstyle></msup><mo>→</mo><mstyle mathvariant="normal"><mi>S</mi><mi>e</mi><mi>t</mi></mstyle></mrow><annotation encoding="application/x-tex">\textsf{CartSp}^{\mathrm{op}}\to \mathrm{Set}</annotation></semantics></math> Think of one presheaf <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> (suggestive name) as a would-be space together with the specification of what probing functions are smooth. Sometimes these probes are called <em>plots</em>. These are different from charts. Charts are specific homeomorphisms that cover <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>. Here we must provide the entire set of all possible smooth functions into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math>, for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.</p>
<p>The category <span class="sans-serif">Psh</span>(<span class="sans-serif">CartSp</span>) consists of all such functors, together with the natural transformations between them. This is an interesting category! If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> is any locally small category, there is an embedding (a full and faithful functor that is injective on objects) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>→</mo><mtext mathvariant="sans-serif">𝖯𝗌𝗁</mtext><mo stretchy="false" form="prefix">(</mo><mi>C</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">C\to\textsf{Psh}(C)</annotation></semantics></math> called the <em>Yoneda embedding</em>. In fact <span class="sans-serif">Psh</span>(C) is the <em>free cocompletion</em> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>, meaning it freely adds all colimits from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>. In fact <span class="sans-serif">Psh</span>(C) is a <em>topos</em> which is a checklist of wonderful properties, and we’ll be using them all by the end because HoTT and toposes are closely related. In a nutshell, <span class="sans-serif">Psh</span>(C) inherits these nice properties from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖲</mi><mi>𝖾</mi><mi>𝗍</mi></mstyle><annotation encoding="application/x-tex">\mathsf{Set}</annotation></semantics></math>.</p>
<p>BUT.</p>
<p>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> already has some colimits, <span class="sans-serif">Psh</span>(C) will not respect these. It is <em>too free</em>.</p>
<p>Consider two subobjects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n</annotation></semantics></math> in <span class="sans-serif">CartSp</span>, say two disjoint open balls <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>.</p>
<p>Following Duggers we think of sheaves as the subcategory of presheaves that preserve the existing colimits that we had. There is an analogy to specifying a group as the quotient of a free group by a subgroup generated by some relations.</p>
<p>It’s illustrative to understand the layers of exoticness that are introduced by moving from <span class="sans-serif">SmoothMfd</span> to sheaves. Manifolds embed in diffeological spaces which are the concrete sheaves (see Baez and Hoffnung <span class="citation" data-cites="baez_convenient_2008"></span>).</p>
<h1 id="sec:algebras">The algebra of functions</h1>
<p>For a smooth manifold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> the set of smooth real-valued maps <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">f:M\to\ensuremath{\mathbb{R}}</annotation></semantics></math> has the structure of a vector space, a ring, and in fact a commutative algebra. An algebra is a vector space over a base field (hence it has a commutative addition operation) which also has a multiplication operation that satisfies the distributive law when it interacts with addition. If the multiplication is commutative then we say the algebra is commutative. In this case the operations are all pointwise and so the algebra properties are inherited from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>. For example <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">fg(x)=f(x)g(x)</annotation></semantics></math> where the right hand side is multiplication in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>.</p>
<p><span id="prop:algebrafunctor" label="prop:algebrafunctor">[prop:algebrafunctor]</span> Taking the algebra <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ensuremath{C^{\infty}}(M)</annotation></semantics></math> of smooth functions of a smooth manifold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> gives a contravariant functor <span class="math inline">$\textsf{SmoothMfd}\xrightarrow[]{\ensuremath{C^{\infty}}}\textsf{CAlg}_{\ensuremath{\mathbb{R}}}^{\mathrm{op}}$</span>.</p>
<p>There are important subcategories of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="sans-serif">𝖢𝖠𝗅𝗀</mtext><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></msub><annotation encoding="application/x-tex">\textsf{CAlg}_{\ensuremath{\mathbb{R}}}</annotation></semantics></math> that themselves contain the image of this functor, notably the “smooth algebras” but we won’t make use of their special properties, so we might as well use the simpler larger category.</p>
<p>Crucially this functor is actually <em>faithful</em>, meaning if you fix two manifolds then the functor is injective on the hom set between them. Said another way, any algebra homomorphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ensuremath{C^{\infty}}(N)\to\ensuremath{C^{\infty}}(M)</annotation></semantics></math> comes from a unique smooth map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M\to N</annotation></semantics></math>. Therefore we can embed <span class="sans-serif">SmoothMfd</span> into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="sans-serif">𝖢𝖠𝗅𝗀</mtext><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></msub><annotation encoding="application/x-tex">\textsf{CAlg}_{\ensuremath{\mathbb{R}}}</annotation></semantics></math> and treat its image as an equivalent copy of <span class="sans-serif">SmoothMfd</span> (with arrows reversed) and find new ways to extend it and build new categories!</p>
<p>The proof of faithfulness is interesting and we will explore it fully because it’s challenging to piece it together from the references that exist easily to hand today. Since we have a couple other such “smooth facts” to make use of let’s handle them together.</p>
<h1 id="sec:smoothnesslemmas">The lemmas about smoothness</h1>
<p><span id="lemma:smoothfact1" label="lemma:smoothfact1">[lemma:smoothfact1]</span>(“Milnor’s Exercise”) The map <span class="math inline">$M\xrightarrow[]{\mathrm{ev}}\mathrm{Hom}(\ensuremath{C^{\infty}}(M),\ensuremath{\mathbb{R}})=\mathrm{Hom}(\ensuremath{C^{\infty}}(M),\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}}^0))$</span> given by evaluation at a point of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> is a bijection.</p>
<p>See also Kolář, Michor and Slovák <span class="citation" data-cites="kolar_natural_1993"></span>, especially the preamble before section 35 and Corollary 35.9. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>∈</mo><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi\in\mathrm{Hom}(\ensuremath{C^{\infty}}(M), \ensuremath{\mathbb{R}})</annotation></semantics></math>. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ker</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ker(\phi)</annotation></semantics></math> is an ideal of codimension 1. (An ideal of an algebra is a vector subspace which is closed under multiplication by an arbitrary element of the algebra.) Consider the collection of zero sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>f</mi></msub><mo>,</mo><mi>f</mi><mo>∈</mo><mo>ker</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Z_f, f\in \ker(\phi)</annotation></semantics></math>. This collection of sets is closed under intersection: given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>f</mi></msub><mo>,</mo><msub><mi>Z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">Z_f, Z_g</annotation></semantics></math> then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>f</mi><mn>2</mn></msup><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo>=</mo><msub><mi>Z</mi><mi>f</mi></msub><mo>∪</mo><msub><mi>Z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">Z_{(f^2+g^2)} = Z_f\cup Z_g</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mn>2</mn></msup><mo>+</mo><msup><mi>g</mi><mn>2</mn></msup><mo>∈</mo><mo>ker</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f^2+g^2\in\ker(\phi)</annotation></semantics></math>. We have satisfied some of the hypotheses of the following topological lemma:</p>
<p>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is Hausdorff and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">C\subseteq X</annotation></semantics></math> compact, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">F=\{C_i\}</annotation></semantics></math> any collection of closed subsets of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> with the property that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>,</mo><msub><mi>C</mi><mi>j</mi></msub><mo>∈</mo><mi>F</mi><mo>⟹</mo><msub><mi>C</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>C</mi><mi>j</mi></msub><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">C_i, C_j\in F\implies C_i\cap C_j\in F</annotation></semantics></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋂</mo><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub><mo>≠</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\bigcap_i C_i \neq\emptyset</annotation></semantics></math>.</p>
<p>We have a collection of sets closed under intersection, so to satisfy the hypotheses of this new lemma it suffices to show that there is some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>f</mi></msub><annotation encoding="application/x-tex">Z_f</annotation></semantics></math> compact and nonempty, for then we can use this as the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
<p>Suppose for a moment that we had this <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>f</mi></msub><annotation encoding="application/x-tex">Z_f</annotation></semantics></math>. Let’s see how we can finish proving Milnor’s exercise. Suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋂</mo><mrow><mi>f</mi><mo>∈</mo><mo>ker</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><msub><mi>Z</mi><mi>f</mi></msub><mo>≠</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">\bigcap_{f\in\ker(\phi)}Z_f\neq\emptyset</annotation></semantics></math>, and so it contains some point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. Now consider an arbitrary <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>,</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g\in\ensuremath{C^{\infty}}(M,\ensuremath{\mathbb{R}})</annotation></semantics></math>. Construct the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>′</mi><mo>=</mo><mi>g</mi><mo>−</mo><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g&#39;=g-\phi(g)1</annotation></semantics></math> where the latter term means the constant function with value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(g)</annotation></semantics></math>. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>′</mi><mo>∈</mo><mo>ker</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g&#39;\in\ker(\phi)</annotation></semantics></math>, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>′</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g&#39;(x)=0</annotation></semantics></math>, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mn>1</mn><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g(x)-\phi(g)1(x)=0</annotation></semantics></math> and hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(g)=g(x)</annotation></semantics></math>, and so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>=</mo><msub><mstyle mathvariant="normal"><mi>e</mi><mi>v</mi></mstyle><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\phi=\mathrm{ev}_x</annotation></semantics></math> as desired.</p>
<p>Now to construct the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> whose zero set is compact and nonempty. Back in Definition <a href="#def:smoothmfd" data-reference-type="ref" data-reference="def:smoothmfd">[def:smoothmfd]</a> we assumed all our smooth manifolds are Hausdorff with countable basis. This in turn implies paracompactness, a property that was put on this Earth to supply the existence of a <em>partition of unity</em>, a countable collection of smooth bump functions, each with compact support, and with the collective property that in a neighborhood of any point only finitely many of them are nonzero, and they sum everywhere to the constant function 1. So let’s fix a partition of unity <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>f</mi><mi>i</mi></msub><msub><mo stretchy="false" form="postfix">}</mo><mrow><mi>i</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></mrow></msub></mrow><annotation encoding="application/x-tex">\{f_i\}_{i\in\ensuremath{\mathbb{N}}}</annotation></semantics></math>. Consider the function <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>f</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><mi>⋯</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">g=f_1+2f_2+3f_1+\cdots.</annotation></semantics></math> This function is everywhere positive. We claim that for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c&gt;0</annotation></semantics></math> that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U=g^{-1}([0,c])</annotation></semantics></math> is compact. By continuity <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> is closed. And it must lie in the union of finitely many supports, as the terms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><msub><mi>f</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">nf_n</annotation></semantics></math> grow beyond <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> eventually. So <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> is closed and contained in a finite union of compact sets, which is compact, and so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> is compact. One more trick: this argument works for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mn>2</mn></msup><annotation encoding="application/x-tex">g^2</annotation></semantics></math> as well, possibly with a different value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>. Since the codimention of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ker</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ker(\phi)</annotation></semantics></math> is 1, some linear combination <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>a</mi><mi>g</mi><mo>+</mo><mi>b</mi><msup><mi>g</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">f=ag+bg^2=0, a, b\in\ensuremath{\mathbb{R}}</annotation></semantics></math>. This <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> carves out a compact nonempty zero set.</p>
<p>It is perhaps notable that there is a larger class of topological manifolds for which Milnor’s exercise holds, which goes by the name <em>realcompact</em>, in case you want to look that up.</p>
<p><span id="lemma:smoothfact2" label="lemma:smoothfact2">[lemma:smoothfact2]</span> For two smooth manifolds <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>1</mn></msub><annotation encoding="application/x-tex">M_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>2</mn></msub><annotation encoding="application/x-tex">M_2</annotation></semantics></math> the map <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo>,</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>→</mo><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"><mi>f</mi></mtd><mtd columnalign="left"><mo>↦</mo><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo>↦</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\ensuremath{C^{\infty}}(M_1, M_2) &amp;\to \mathrm{Hom}(\ensuremath{C^{\infty}}(M_2),\ensuremath{C^{\infty}}(M_1)) \\
f &amp;\mapsto (g\mapsto g\circ f)\end{aligned}</annotation></semantics></math> given by precomposition is a bijection, i.e. <span class="math inline">$\textsf{SmoothMfd}\xrightarrow[]{\ensuremath{C^{\infty}}}\textsf{CAlg}_{\ensuremath{\mathbb{R}}}^{\mathrm{op}}$</span> is faithful.</p>
<p>Given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>∈</mo><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi\in\mathrm{Hom}(\ensuremath{C^{\infty}}(M_2),\ensuremath{C^{\infty}}(M_1))</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>∈</mo><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1\in M_1</annotation></semantics></math> we need to produce a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>∈</mo><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2\in M_2</annotation></semantics></math> and to show that this mapping <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>↦</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1\mapsto x_2</annotation></semantics></math> is smooth. Consider <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="normal"><mi>e</mi><mi>v</mi></mstyle><msub><mi>x</mi><mn>1</mn></msub></msub><mo>∘</mo><mi>ϕ</mi><mo>∈</mo><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ev}_{x_1}\circ\phi\in\mathrm{Hom}(\ensuremath{C^{\infty}}(M_2),\ensuremath{\mathbb{R}})</annotation></semantics></math>: <span class="math display">$$\ensuremath{C^{\infty}}(M_2)\xrightarrow[]{\phi}\ensuremath{C^{\infty}}(M_1)\xrightarrow[]{\mathrm{ev_{x_1}}} \ensuremath{\mathbb{R}}.$$</span> By Lemma <a href="#lemma:smoothfact1" data-reference-type="ref" data-reference="lemma:smoothfact1">[lemma:smoothfact1]</a> this is equal to evaluation at some point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>∈</mo><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2\in M_2</annotation></semantics></math>, so define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msub><mi>M</mi><mn>1</mn></msub><mo>→</mo><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f:M_1\to M_2</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>↦</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1\mapsto x_2</annotation></semantics></math>. We have shown that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\phi(g)=g\circ f</annotation></semantics></math> and so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g\circ f</annotation></semantics></math> is smooth for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>, which suffices to prove that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is smooth.</p>
<p>Note that Lemma <a href="#lemma:smoothfact2" data-reference-type="ref" data-reference="lemma:smoothfact2">[lemma:smoothfact2]</a> is a generalization of Lemma <a href="#lemma:smoothfact1" data-reference-type="ref" data-reference="lemma:smoothfact1">[lemma:smoothfact1]</a> but we used the more specific one to prove the more general one.</p>
<p>For our purposes these lemmas serve to allow us to pass to the image of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>C</mi><mi>∞</mi></msup><annotation encoding="application/x-tex">\ensuremath{C^{\infty}}</annotation></semantics></math> in the category of algebras and proceed to enlarge it in new ways that are made possible by the algebraic setting. We will do that by extending the algebras with nilpotent elements!</p>
<h1 id="sec:nilpotents">Nilpotents</h1>
<p>An element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\in A</annotation></semantics></math> of a real algebra is nilpotent if some power of it is zero. For example in the 4-dimensional algebra of 2x2 real matrices the element <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">M=\begin{pmatrix}
    0 &amp; 1 \\
    0 &amp; 0
  \end{pmatrix}</annotation></semantics></math> satisfies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M^2=0</annotation></semantics></math>. A more important example for us is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}[x]/x^2</annotation></semantics></math>, which is the polynomial algebra over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math> modulo the ideal generated by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mn>2</mn></msup><annotation encoding="application/x-tex">x^2</annotation></semantics></math>, which is equivalent to adding the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2=0</annotation></semantics></math>. This truncates the polynomials to have degree at most 1, so this is a 2-dimensional real algebra. (Contrast this with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}[x]/x^2+1</annotation></semantics></math> which is also 2-dimensional but does not add any nilpotent elements; it in fact is isomorphic to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>.) What if we add nilpotents to the story about algebras of smooth functions?</p>
<p>Now is a good time to expand our list of facts about smoothness with two more.</p>
<p>(Hadamard)<span id="lemma:hadamard" label="lemma:hadamard">[lemma:hadamard]</span> If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>→</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">f:\ensuremath{\mathbb{R}}^n\to\ensuremath{\mathbb{R}}</annotation></semantics></math> is smooth then in some open neighborhood <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>⊇</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U\supseteq (0,\ldots,0)</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>x</mi><mi>i</mi></msub><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x_1,\ldots,x_n) = f(0) + \sum_{i=1}^n x_i g_i(x_1,\ldots,x_n)</annotation></semantics></math> for smooth functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>i</mi></msub><annotation encoding="application/x-tex">g_i</annotation></semantics></math> satisfying <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mrow><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">|</mo></mrow><mrow><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">g(0,\ldots,0) = \left.\frac{\partial f}{\partial x_i}(x_1,\ldots,x_n)\right|_{(0,\ldots,0)}</annotation></semantics></math></p>
<p>Elementary special case of Taylor’s theorem.</p>
<p><span id="lemma:tangent" label="lemma:tangent">[lemma:tangent]</span><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Hom}(\ensuremath{C^{\infty}}(M),\ensuremath{\mathbb{R}}[x]/x^2)</annotation></semantics></math> is in bijection with derivations on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p>
<p><span class="math display">$$\begin{aligned}
f &amp;\mapsto A(f) + B(f)x \\
fg &amp;\mapsto (A(f) + B(f)x)(A(g)+B(g)x)&amp;\quad \\
&amp;= A(f)A(g) + (A(f)B(g) + B(f)A(g))x &amp;\mathrm{so\ } A \mathrm{\ is\ itself\ an\ algebra\ homomorphism} \\
&amp;= f(m)g(m) + (f(m)B(g) + B(f)g(m))x &amp;\mathrm{for\ some\ } m\in M\mathrm{\ by\ Lemma~\ref{lemma:smoothfact1}}\end{aligned}$$</span> So <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is a derivation at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">m\in M</annotation></semantics></math> and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math> be a coordinate chart around <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> with map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>U</mi><mo>≅</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\phi:U\cong\ensuremath{\mathbb{R}}^n</annotation></semantics></math>. A tangent vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>m</mi></msub><annotation encoding="application/x-tex">v_m</annotation></semantics></math> at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> is an equivalence class of maps <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\gamma:\ensuremath{\mathbb{R}}\to M</annotation></semantics></math> satisfying <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\gamma(0)=m</annotation></semantics></math> under the equivalence relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>γ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\gamma_1\sim\gamma_2</annotation></semantics></math> iff <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>∘</mo><msub><mi>γ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\phi\circ\gamma_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>∘</mo><msub><mi>γ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\phi\circ\gamma_2</annotation></semantics></math> have the same derivative at 0.</p>
<p><span id="lemma:derivationsaretangentvectors" label="lemma:derivationsaretangentvectors">[lemma:derivationsaretangentvectors]</span>For <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">m\in M</annotation></semantics></math>, derivations at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> are in bijection with tangent vectors at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<p>Hadamard’s Lemma plus the definition of a vector field as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo><mfrac><mi>∂</mi><mrow><mi>∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n v_i(x_1,\ldots,x_n)\frac{\partial}{\partial x_i}</annotation></semantics></math>.</p>
<p>Moral: in the dual world of spaces, this algebra with nilpotents is probing both the points of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> and its tangent vectors. It is a point with &quot;nilpotent fuzz&quot;. It is an abstract tangent vector, just long enough to point in some direction.</p>
<p>Let me emphasize the choices we have available with nilpotents. If we were to probe with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}[x,y]/x^2,y^2</annotation></semantics></math> we’d have an equivalence class of smooth maps <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^2\to M</annotation></semantics></math> instead of tangent vectors. Meanwhile if we used a single variable but a higher power such as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}[x]/x^3</annotation></semantics></math>, the equivalence relation between curves would require agreement of the second derivative. We could carry through the rest of our discussion with any of these choices.</p>
<h1 id="sec:nilpotentstocartsp">Adding nilpotents to <span class="sans-serif">CartSp</span></h1>
<p>We define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext><annotation encoding="application/x-tex">\textsf{FormalCartSp}</annotation></semantics></math> as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext><mo>:=</mo><mstyle mathvariant="normal"><mi>o</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mspace width="0.222em"></mspace><mi>o</mi><mi>f</mi><mspace width="0.222em"></mspace></mstyle><mrow><mo stretchy="true" form="prefix">{</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="postfix">)</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>⊕</mo><mstyle mathvariant="double-struck"><mi>𝕍</mi></mstyle><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>𝕍</mi></mstyle><mi>k</mi></msup><mo>=</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>n</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><mo stretchy="true" form="postfix">}</mo></mrow><mo>↪</mo><msubsup><mtext mathvariant="sans-serif">𝖢𝖠𝗅𝗀</mtext><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mstyle mathvariant="normal"><mi>o</mi><mi>p</mi></mstyle></msubsup></mrow><annotation encoding="application/x-tex">\textsf{FormalCartSp}:= \mathrm{opposite\ of\ }\left\{\ensuremath{C^{\infty}})\ensuremath{\mathbb{R}}^n)\otimes\ensuremath{\mathbb{R}}\oplus\mathbb{V}, \mathbb{V}^k=0, k,n\in\ensuremath{\mathbb{N}}\right\}\hookrightarrow \textsf{CAlg}_{\ensuremath{\mathbb{R}}}^{\mathrm{op}}</annotation></semantics></math></p>
<p>This dual description is the one we can get our hands on, but there is an intuitive picture we should keep in mind: think of the objects in this category as spaces <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>↔</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>⊕</mo><mstyle mathvariant="double-struck"><mi>𝕍</mi></mstyle><mstyle mathvariant="normal"><mspace width="0.222em"></mspace><mi>w</mi><mi>i</mi><mi>t</mi><mi>h</mi><mspace width="0.222em"></mspace></mstyle><msup><mstyle mathvariant="double-struck"><mi>𝕍</mi></mstyle><mi>m</mi></msup><mo>=</mo><mn>0</mn><mstyle mathvariant="normal"><mspace width="0.222em"></mspace><mi>f</mi><mi>o</mi><mi>r</mi><mspace width="0.222em"></mspace><mi>s</mi><mi>o</mi><mi>m</mi><mi>e</mi><mspace width="0.222em"></mspace></mstyle><mi>m</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n\times\ensuremath{\mathbb{D}}\leftrightarrow\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}}^n)\otimes\ensuremath{\mathbb{R}}\oplus\mathbb{V}\mathrm{\ with\ }\mathbb{V}^m=0\mathrm{\ for\ some\ }m.</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><annotation encoding="application/x-tex">\mathbb{D}</annotation></semantics></math>is an &quot;infinitesimal disk&quot;, a point with a nilpotent cloud or fuzz around it. That fuzz can probe the tangent directions of a manifold. In the dual algebra space it can take derivatives.</p>
<p>Why the tensor product? It’s teh coproduct in the category of commutative algebras.</p>
<p>We will now make <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext><annotation encoding="application/x-tex">\textsf{FormalCartSp}</annotation></semantics></math> into a site so as to take sheaves over it. We define a Grothendieck pre-topology with covering families <span class="math display">$$\left\{U_i\times\ensuremath{\mathbb{D}}\xrightarrow[]{\phi_i\times\mathrm{id}}\ensuremath{\mathbb{R}}^n\times\ensuremath{\mathbb{D}}\right\}_i\mathrm{\ such\ that\ }\left\{U_i\xrightarrow[]{\phi_i}\ensuremath{\mathbb{R}}^n\right\}_i$$</span> is a covering family in <span class="sans-serif">CartSp</span>. So the only way to cover the formal disk parts is via the identity.</p>
<p>We define <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext><mo>:=</mo><mtext mathvariant="sans-serif">𝖲𝗁</mtext><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\textsf{FormalSmoothSet}:=\textsf{Sh}(\textsf{FormalCartSp}).</annotation></semantics></math> These are spaces defined by a consistent declaration of all the smooth maps from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mi>.</mi></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}}^n\times\ensuremath{\mathbb{D}}.</annotation></semantics></math></p>
<h1 id="sec:functors">Functors and Kan extension</h1>
<p>First we’ll look at the functors in <span class="sans-serif">FormalCartSp</span>, and then extend them to sheaves with Kan extension.</p>
<p>Projection: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>p</mi><mi>r</mi><mo>:</mo><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mtd><mtd columnalign="left"><mo>→</mo><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mtd></mtr><mtr><mtd columnalign="right"><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle></mtd><mtd columnalign="left"><mo>↦</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup></mtd></mtr><mtr><mtd columnalign="right"><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow></mtd><mtd columnalign="left"><mo>↦</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
pr:\textsf{FormalCartSp}&amp;\to\textsf{CartSp}\\
\ensuremath{\mathbb{R}}^n\times\ensuremath{\mathbb{D}}&amp;\mapsto \ensuremath{\mathbb{R}}^n \\
\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}[x]/x^2}&amp;\mapsto \ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}}\\\end{aligned}</annotation></semantics></math></p>
<p>Inclusion:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>i</mi><mo>:</mo><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mtd><mtd columnalign="left"><mo>↪</mo><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mtd></mtr><mtr><mtd columnalign="right"><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup></mtd><mtd columnalign="left"><mo>↦</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="right"><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mtd><mtd columnalign="left"><mo>↦</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
i:\textsf{CartSp}&amp;\hookrightarrow\textsf{FormalCartSp}\\
\ensuremath{\mathbb{R}^n}&amp;\mapsto \ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}_0 \\
\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}}&amp;\mapsto\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}[x]/x^2}\\\end{aligned}</annotation></semantics></math></p>
<p>Tangent:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>T</mi><mo>:</mo><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mtd><mtd columnalign="left"><mo>↪</mo><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mtd></mtr><mtr><mtd columnalign="right"><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>1</mn></msub></mtd><mtd columnalign="left"><mo>↦</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>1</mn></msub><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign="right"><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow></mtd><mtd columnalign="left"><mo>↦</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>y</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>y</mi><mn>2</mn></msup></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
T:\textsf{FormalCartSp}&amp;\hookrightarrow\textsf{FormalCartSp}\\
\ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}_1 &amp;\mapsto \ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}_1\times\ensuremath{\mathbb{D}}_2 \\
\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}[x]/x^2}&amp;\mapsto\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}[x]/x^2}\otimes\ensuremath{\mathbb{R}[y]/y^2}\\\end{aligned}</annotation></semantics></math></p>
<p>A tangent bundle <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TM</annotation></semantics></math> comes equipped with a projection map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>T</mi><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">p:TM\to M</annotation></semantics></math> and a zero map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>:</mo><mi>M</mi><mo>→</mo><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">0:M\to TM</annotation></semantics></math>. In our setting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> become natural transformations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>T</mi><mo>→</mo><mtext mathvariant="normal">id</mtext></mrow><annotation encoding="application/x-tex">p:T\to\ensuremath{\text{id}}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>:</mo><mtext mathvariant="normal">id</mtext><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">0:\ensuremath{\text{id}}\to T</annotation></semantics></math>. We can see that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mi>i</mi><mo>∘</mo><mi>p</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">0=i\circ pr</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">p=</annotation></semantics></math>.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>⊣</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">i\dashv p</annotation></semantics></math> and so <span class="sans-serif">CartSp</span> is coreflective inside <span class="sans-serif">FormalCartSp</span>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>0</mn></msub><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><msub><mtext mathvariant="sans-serif">𝖢𝖠𝗅𝗀</mtext><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></msub></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>⊕</mo><mstyle mathvariant="double-struck"><mi>𝕍</mi></mstyle><mo>,</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><msub><mtext mathvariant="sans-serif">𝖢𝖠𝗅𝗀</mtext><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></msub></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>,</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="1.0em"></mspace><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mi>i</mi><mi>l</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mspace width="0.222em"></mspace><mi>m</mi><mi>u</mi><mi>s</mi><mi>t</mi><mspace width="0.222em"></mspace><mi>m</mi><mi>a</mi><mi>p</mi><mspace width="0.222em"></mspace><mi>t</mi><mi>o</mi><mspace width="0.222em"></mspace><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mstyle></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>,</mo><mi>p</mi><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{Hom}_{\textsf{FormalCartSp}}(i(\ensuremath{\mathbb{R}^n}), \ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}) &amp;= \mathrm{Hom}_{\textsf{FormalCartSp}}(\ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}_0, \ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}) \\
&amp;\cong \mathrm{Hom}_{\textsf{CAlg}_{\ensuremath{\mathbb{R}}}}(\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^m})\otimes\ensuremath{\mathbb{R}}\oplus\ensuremath{\mathbb{V}}, \ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})) \\
&amp;\cong \mathrm{Hom}_{\textsf{CAlg}_{\ensuremath{\mathbb{R}}}}(\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^m})\otimes\ensuremath{\mathbb{R}}, \ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n}))\quad\mathrm{(nilpotents\ must\ map\ to\ 0)} \\
&amp;\cong \mathrm{Hom}_{\textsf{CartSp}}(\ensuremath{\mathbb{R}^n}, \ensuremath{\mathbb{R}^m}) \\
&amp;\cong \mathrm{Hom}_{\textsf{CartSp}}(\ensuremath{\mathbb{R}^n}, p(\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}))\end{aligned}</annotation></semantics></math></p>
<p>One must also show these are all natural in both slots.</p>
<p>Note the finding from line 2-3: maps from a nilpotent algebra to one with no nilpotents must be trivial on the nilpotents, i.e. <em>a space without fuzz cannot probe fuzz</em>.</p>
<p>Functors, like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>, induce three functors on presheaves. For an elementary introduction see Awodey <span class="citation" data-cites="awodey_introduction_2010"></span>, especially Corollary 9.17.</p>
<p><span class="math display">$$\begin{tikzcd}[row sep=huge, column sep=huge]
\textsf{SmoothSet}\arrow[r, &quot;\mkern-16mu i_!&quot;{name=F}, bend left=25]
\arrow[r, &quot;\quad i^*&quot;{name=G}]
\arrow[phantom, from=F, to=G, &quot;\ \dashv&quot; rotate=-90]
&amp; \textsf{FormalSmoothSet}\arrow[l, &quot;\mkern-12mu i_*&quot;{name=H}, swap, bend left=25]
\arrow[phantom, from=G, to=H, &quot;\ \dashv&quot; rotate=-90] \\
\textsf{CartSp}\arrow[u, &quot;y&quot;] \arrow[r, &quot;i&quot;{name=I}, shift left=2.0ex]
&amp; \textsf{FormalCartSp}\arrow[l, &quot;p&quot;{name=P}, shift left=2.0ex, swap]
\arrow[u, &quot;y&quot;, swap]
\arrow[phantom, from=I, to=P, &quot;\dashv&quot; rotate=-90]
\end{tikzcd}$$</span></p>
<p>What do these extensions do?</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>i</mi><mo>*</mo></msup><annotation encoding="application/x-tex">i^*</annotation></semantics></math> is the precomposition functor. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi>s</mi><mo>∈</mo><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></mrow><annotation encoding="application/x-tex">fss\in\textsf{FormalSmoothSet}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>∈</mo><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}^n}\in\textsf{CartSp}</annotation></semantics></math>. Then <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo>*</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>s</mi><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mi>s</mi><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>i</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">i^*(fss)(\ensuremath{\mathbb{R}^n})=fss(i\ensuremath{\mathbb{R}^n}).</annotation></semantics></math> And on representables <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>,</mo><msub><mi>i</mi><mo>*</mo></msub><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>i</mi><mo>*</mo></msup><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>,</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mi>p</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>,</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mspace width="1.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><mspace width="0.222em"></mspace></mstyle><msup><mi>i</mi><mo>*</mo></msup><mi>y</mi><mo>=</mo><mi>y</mi><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{Hom}_{\textsf{FormalSmoothSet}}(y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}, i_*y\ensuremath{\mathbb{R}^n}) &amp;\cong \mathrm{Hom}_{\textsf{SmoothSet}}(i^*y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}, y\ensuremath{\mathbb{R}^n}) \\
&amp;\cong \mathrm{Hom}_{\textsf{SmoothSet}} (yp\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}, y\ensuremath{\mathbb{R}^n})\quad(\mathrm{because\ }i^*y=yp)\\
&amp;\cong \mathrm{Hom}_{\textsf{CartSp}} (\ensuremath{\mathbb{R}^m}, \ensuremath{\mathbb{R}^n})\end{aligned}</annotation></semantics></math></p>
<p>This is a hint that it is taking a space to one that cannot be probed by the infinitesimals.</p>
<p>We can package all of these considerations into endofunctors on just FSS: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>ℜ</mi></mtd><mtd columnalign="left"><mo>=</mo><msub><mi>i</mi><mi>!</mi></msub><mo>∘</mo><msup><mi>i</mi><mo>*</mo></msup></mtd></mtr><mtr><mtd columnalign="right"><mi>ℑ</mi></mtd><mtd columnalign="left"><mo>=</mo><msub><mi>i</mi><mo>*</mo></msub><mo>∘</mo><msup><mi>i</mi><mo>*</mo></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\Re&amp;= i_!\circ i^* \\
\Im&amp;= i_*\circ i^*\end{aligned}</annotation></semantics></math> On representables <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>ℜ</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><msub><mi>i</mi><mi>!</mi></msub><msup><mi>i</mi><mo>*</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><msub><mi>i</mi><mi>!</mi></msub><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mi>y</mi><mi>i</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>0</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\Re(y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}) &amp;= i_!i^*(y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}) \\
&amp;= i_!y\ensuremath{\mathbb{R}^m}\\
&amp;= yi\ensuremath{\mathbb{R}^m}\\
&amp;= y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}_0\end{aligned}</annotation></semantics></math> and so &quot;reduction&quot; just projects away the nilpotent parts of a (representable) formal smooth set.</p>
<p>We also have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℜ</mi><mo>⊣</mo><mi>ℑ</mi></mrow><annotation encoding="application/x-tex">\Re\dashv\Im</annotation></semantics></math>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>U</mi><mo>,</mo><mi>ℑ</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>U</mi><mo>,</mo><msub><mi>i</mi><mo>*</mo></msub><msup><mi>i</mi><mo>*</mo></msup><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>i</mi><mo>*</mo></msup><mi>U</mi><mo>,</mo><msup><mi>i</mi><mo>*</mo></msup><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>i</mi><mi>!</mi></msub><msup><mi>i</mi><mo>*</mo></msup><mi>U</mi><mo>,</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>ℜ</mi><mi>U</mi><mo>,</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{Hom}_{\textsf{FormalSmoothSet}}(U, \Im M)&amp;\cong\mathrm{Hom}_{\textsf{FormalSmoothSet}}(U,i_* i^*M) \\
&amp;\cong \mathrm{Hom}_{\textsf{SmoothSet}}(i^*U, i^*M) \\
&amp;\cong \mathrm{Hom}_{\textsf{FormalSmoothSet}}(i_!i^*U, M) \\
&amp;\cong \mathrm{Hom}_{\textsf{FormalSmoothSet}}(\Re U, M)\end{aligned}</annotation></semantics></math> And so what if we start with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mi>′</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Hom}_{\textsf{FormalCartSp}}(\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}, \ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}&#39;)</annotation></semantics></math> and t hen hit the right hand space with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℑ</mi><annotation encoding="application/x-tex">\Im</annotation></semantics></math>? <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>,</mo><mi>ℑ</mi><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mi>′</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>ℜ</mi><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mo>,</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mi>′</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖲𝗆𝗈𝗈𝗍𝗁𝖲𝖾𝗍</mtext></msub><mo stretchy="false" form="prefix">(</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>0</mn></msub><mo>,</mo><mi>y</mi><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mi>′</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>≅</mo><msub><mstyle mathvariant="normal"><mi>H</mi><mi>o</mi><mi>m</mi></mstyle><mtext mathvariant="sans-serif">𝖥𝗈𝗋𝗆𝖺𝗅𝖢𝖺𝗋𝗍𝖲𝗉</mtext></msub><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>m</mi></msup><mo>×</mo><msub><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mn>0</mn></msub><mo>,</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo>×</mo><mstyle mathvariant="double-struck"><mi>𝔻</mi></mstyle><mi>′</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{Hom}_{\textsf{FormalSmoothSet}}(y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}, \Im y\ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}&#39;) &amp;\cong \mathrm{Hom}_{\textsf{FormalSmoothSet}}(\Re y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}, y\ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}&#39;) \\
&amp;\cong \mathrm{Hom}_{\textsf{FormalSmoothSet}}(y\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}_0, y\ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}&#39;) \\
&amp;\cong \mathrm{Hom}_{\textsf{FormalCartSp}}(\ensuremath{\mathbb{R}^m}\times\ensuremath{\mathbb{D}}_0, \ensuremath{\mathbb{R}^n}\times\ensuremath{\mathbb{D}}&#39;)\end{aligned}</annotation></semantics></math> and so a coreduced FSS is one whose probes, even with nilpotents, cannot see the tangent directions. Its tangent directions are collapsed or identified.</p>
<p>“Infinitesimally close points are identified.”</p>
<p>So in spirit there is a relation “x and y are infinitesimally close” which connects with SDG. But now we can get at it with a modal operator.</p>
<h1 id="sec:modality">The modality</h1>
<p>Differential cohesion is most gently introduced by Khavkine and Schreiber in <span class="citation" data-cites="khavkine_synthetic_2017"></span> and plays a large role in Schreiber’s magnum opus <span class="citation" data-cites="schreiber_differential_2013"></span>.</p>
<h1 id="towards-connections">Towards connections</h1>
<p>To have connections we need both <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TM</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TTM</annotation></semantics></math>. Eventually we need to define vector bundles <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math> as a slice category, and then we’ll need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">TE</annotation></semantics></math>. But in the case of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TTM</annotation></semantics></math> how can we get there with an idempotent modality?</p>
<p>I think the key is to introduce a variable into the modal operator: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℑ</mi><mi>x</mi></msub><mo>,</mo><msub><mi>ℑ</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">\Im_x, \Im_y</annotation></semantics></math>. At the algebra level these will come from <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow><mo>⊗</mo><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>y</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>y</mi><mn>2</mn></msup></mrow><mo>=</mo><msup><mi>C</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msup><mi>y</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}[x]/x^2}\otimes\ensuremath{\mathbb{R}[y]/y^2}= \ensuremath{C^{\infty}}(\ensuremath{\mathbb{R}^n})\otimes\ensuremath{\mathbb{R}}[x, y]/(x^2, y^2)</annotation></semantics></math>. Each modal operator is idempotent. Adding the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> variable again doesn’t provide more fuzziness, or more tangency, or more directions to differentiate in. But adding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> does.</p>
<p>It’s crucial that the differentiation these variables are doing will commute with each other, so that it doesn’t matter which one was tensored outermost.</p>
<p>Having the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> lets you differentiate everything, and adding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> lets you differentiate everything including the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> (i.e. there are now terms in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math>).</p>
<p>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\ensuremath{\mathbb{R}[x]/x^2}</annotation></semantics></math> leads to an interpretation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℑ</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\Im_x</annotation></semantics></math> then we can indeed have two of them.</p>
<p>I also want to add a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>A</mi><mo>=</mo><mi>A</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">TA=A[x]/x^2</annotation></semantics></math> which I hope is equal to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></msub><mrow><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">A\otimes_{\ensuremath{\mathbb{R}}}\ensuremath{\mathbb{R}[x]/x^2}</annotation></semantics></math>. Perhaps the unit of this is the zero section. Then we would have two functors, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>, and the units are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>. We’ll need better names. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> are inverses on the nose. The Kan extensions will convert between sets of probes that can see the tangent space and those that cannot.</p>
<p>When there are two modalities, the Kan extensions will move between sets of probes that can see 0, 1 or 2 iterated copies of the tangent space.</p>
<p>There is always a map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>M</mi><mo>→</mo><msub><mi>T</mi><mn>2</mn></msub><mi>M</mi><mo>=</mo><mi>T</mi><mi>M</mi><msub><mo>×</mo><mi>M</mi></msub><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TTM\to T_2 M=TM\times_M TM</annotation></semantics></math>, where the right hand side is the pullback of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TM</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, i.e. each fiber over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> is two copies of the tangent bundle.</p>
<p>A connection is a section of this map, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><msub><mi>T</mi><mn>2</mn></msub><mi>M</mi><mo>→</mo><mi>T</mi><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">L:T_2 M\to TTM</annotation></semantics></math>. Given two tangent vectors you can lift that pair up to a vector in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TTM</annotation></semantics></math>, in fact a horizontal one. The image of the connection map is the horizontal sub-bundle of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>T</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">TTM</annotation></semantics></math>. The kernel of the bundle projection is the vertical sub-bundle.</p>
<p>What types will we have? Apparently we’ll have ones that &quot;are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of something&quot; and ones that are not. If you are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of something then you can be probed by nilpotents, and you are not coreduced. Else you are coreduced. To be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> of something you must be differentiable everywhere. Perhaps this is why <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sum_{a:A}B(a)</annotation></semantics></math> is coreduced whenever <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is.</p>
<p>Infinitesimal closeness is preserved by morphisms. Equivalently, morphisms are bundle morphisms, they preserve the fibers. Is it also equivalent to stipulate that at the algebra level the morphisms hold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> fixed?</p>
<h1 id="towards-chern-weil-without-coreduction">Towards Chern-Weil, without coreduction</h1>
<p>In Baez-Huerta An Invitation to Higher Gauge Theory we find an elementary explanation about how a 2-connection on a (trivial?) 2-principal bundle associated with a 2-group is a connection plus its curvature. The intuition is simply that the holonomy functor acts on both paths and on squares that fill in the paths – just like curvature. For everything to hang together 2-categorically the curvature appears exactly: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>A</mi><mo>+</mo><mi>A</mi><mo>∧</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">dA + A\wedge A</annotation></semantics></math>.</p>
<p>The technology of 2-connections was invented to support string theory. But if a flat 2-connection contains in it a regular 1-connection that might be curved, then it can also serve to put standard gauge theory in a form that is accessible to modal hott with shape modality, and hence to formalization.</p>

